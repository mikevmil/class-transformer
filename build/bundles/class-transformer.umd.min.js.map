{"version":3,"file":"class-transformer.umd.min.js","sources":["../esm5/enums/transformation-type.enum.js","../esm5/MetadataStorage.js","../esm5/storage.js","../esm5/TransformOperationExecutor.js","../esm5/utils/get-global.util.js","../esm5/ClassTransformer.js","../esm5/index.js","../esm5/decorators/exclude.decorator.js","../esm5/decorators/expose.decorator.js","../esm5/decorators/transform.decorator.js","../esm5/decorators/transform-class-to-class.decorator.js","../esm5/decorators/transform-class-to-plain.decorator.js","../esm5/decorators/transform-plain-to-class.decorator.js","../esm5/decorators/type.decorator.js"],"sourcesContent":["export var TransformationType;\r\n(function (TransformationType) {\r\n    TransformationType[TransformationType[\"PLAIN_TO_CLASS\"] = 0] = \"PLAIN_TO_CLASS\";\r\n    TransformationType[TransformationType[\"CLASS_TO_PLAIN\"] = 1] = \"CLASS_TO_PLAIN\";\r\n    TransformationType[TransformationType[\"CLASS_TO_CLASS\"] = 2] = \"CLASS_TO_CLASS\";\r\n})(TransformationType || (TransformationType = {}));\r\n//# sourceMappingURL=transformation-type.enum.js.map","import { TransformationType } from './enums';\r\n/**\r\n * Storage all library metadata.\r\n */\r\nvar MetadataStorage = /** @class */ (function () {\r\n    function MetadataStorage() {\r\n        // -------------------------------------------------------------------------\r\n        // Properties\r\n        // -------------------------------------------------------------------------\r\n        this._typeMetadatas = new Map();\r\n        this._transformMetadatas = new Map();\r\n        this._exposeMetadatas = new Map();\r\n        this._excludeMetadatas = new Map();\r\n        this._ancestorsMap = new Map();\r\n    }\r\n    // -------------------------------------------------------------------------\r\n    // Adder Methods\r\n    // -------------------------------------------------------------------------\r\n    MetadataStorage.prototype.addTypeMetadata = function (metadata) {\r\n        if (!this._typeMetadatas.has(metadata.target)) {\r\n            this._typeMetadatas.set(metadata.target, new Map());\r\n        }\r\n        this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\r\n    };\r\n    MetadataStorage.prototype.addTransformMetadata = function (metadata) {\r\n        if (!this._transformMetadatas.has(metadata.target)) {\r\n            this._transformMetadatas.set(metadata.target, new Map());\r\n        }\r\n        if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {\r\n            this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);\r\n        }\r\n        this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);\r\n    };\r\n    MetadataStorage.prototype.addExposeMetadata = function (metadata) {\r\n        if (!this._exposeMetadatas.has(metadata.target)) {\r\n            this._exposeMetadatas.set(metadata.target, new Map());\r\n        }\r\n        this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\r\n    };\r\n    MetadataStorage.prototype.addExcludeMetadata = function (metadata) {\r\n        if (!this._excludeMetadatas.has(metadata.target)) {\r\n            this._excludeMetadatas.set(metadata.target, new Map());\r\n        }\r\n        this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\r\n    };\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n    MetadataStorage.prototype.findTransformMetadatas = function (target, propertyName, transformationType) {\r\n        return this.findMetadatas(this._transformMetadatas, target, propertyName).filter(function (metadata) {\r\n            if (!metadata.options)\r\n                return true;\r\n            if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)\r\n                return true;\r\n            if (metadata.options.toClassOnly === true) {\r\n                return (transformationType === TransformationType.CLASS_TO_CLASS ||\r\n                    transformationType === TransformationType.PLAIN_TO_CLASS);\r\n            }\r\n            if (metadata.options.toPlainOnly === true) {\r\n                return transformationType === TransformationType.CLASS_TO_PLAIN;\r\n            }\r\n            return true;\r\n        });\r\n    };\r\n    MetadataStorage.prototype.findExcludeMetadata = function (target, propertyName) {\r\n        return this.findMetadata(this._excludeMetadatas, target, propertyName);\r\n    };\r\n    MetadataStorage.prototype.findExposeMetadata = function (target, propertyName) {\r\n        return this.findMetadata(this._exposeMetadatas, target, propertyName);\r\n    };\r\n    MetadataStorage.prototype.findExposeMetadataByCustomName = function (target, name) {\r\n        return this.getExposedMetadatas(target).find(function (metadata) {\r\n            return metadata.options && metadata.options.name === name;\r\n        });\r\n    };\r\n    MetadataStorage.prototype.findTypeMetadata = function (target, propertyName) {\r\n        return this.findMetadata(this._typeMetadatas, target, propertyName);\r\n    };\r\n    MetadataStorage.prototype.getStrategy = function (target) {\r\n        var excludeMap = this._excludeMetadatas.get(target);\r\n        var exclude = excludeMap && excludeMap.get(undefined);\r\n        var exposeMap = this._exposeMetadatas.get(target);\r\n        var expose = exposeMap && exposeMap.get(undefined);\r\n        if ((exclude && expose) || (!exclude && !expose))\r\n            return 'none';\r\n        return exclude ? 'excludeAll' : 'exposeAll';\r\n    };\r\n    MetadataStorage.prototype.getExposedMetadatas = function (target) {\r\n        return this.getMetadata(this._exposeMetadatas, target);\r\n    };\r\n    MetadataStorage.prototype.getExcludedMetadatas = function (target) {\r\n        return this.getMetadata(this._excludeMetadatas, target);\r\n    };\r\n    MetadataStorage.prototype.getExposedProperties = function (target, transformationType) {\r\n        return this.getExposedMetadatas(target)\r\n            .filter(function (metadata) {\r\n            if (!metadata.options)\r\n                return true;\r\n            if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)\r\n                return true;\r\n            if (metadata.options.toClassOnly === true) {\r\n                return (transformationType === TransformationType.CLASS_TO_CLASS ||\r\n                    transformationType === TransformationType.PLAIN_TO_CLASS);\r\n            }\r\n            if (metadata.options.toPlainOnly === true) {\r\n                return transformationType === TransformationType.CLASS_TO_PLAIN;\r\n            }\r\n            return true;\r\n        })\r\n            .map(function (metadata) { return metadata.propertyName; });\r\n    };\r\n    MetadataStorage.prototype.getExcludedProperties = function (target, transformationType) {\r\n        return this.getExcludedMetadatas(target)\r\n            .filter(function (metadata) {\r\n            if (!metadata.options)\r\n                return true;\r\n            if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)\r\n                return true;\r\n            if (metadata.options.toClassOnly === true) {\r\n                return (transformationType === TransformationType.CLASS_TO_CLASS ||\r\n                    transformationType === TransformationType.PLAIN_TO_CLASS);\r\n            }\r\n            if (metadata.options.toPlainOnly === true) {\r\n                return transformationType === TransformationType.CLASS_TO_PLAIN;\r\n            }\r\n            return true;\r\n        })\r\n            .map(function (metadata) { return metadata.propertyName; });\r\n    };\r\n    MetadataStorage.prototype.clear = function () {\r\n        this._typeMetadatas.clear();\r\n        this._exposeMetadatas.clear();\r\n        this._excludeMetadatas.clear();\r\n        this._ancestorsMap.clear();\r\n    };\r\n    // -------------------------------------------------------------------------\r\n    // Private Methods\r\n    // -------------------------------------------------------------------------\r\n    MetadataStorage.prototype.getMetadata = function (metadatas, target) {\r\n        var metadataFromTargetMap = metadatas.get(target);\r\n        var metadataFromTarget;\r\n        if (metadataFromTargetMap) {\r\n            metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(function (meta) { return meta.propertyName !== undefined; });\r\n        }\r\n        var metadataFromAncestors = [];\r\n        for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {\r\n            var ancestor = _a[_i];\r\n            var ancestorMetadataMap = metadatas.get(ancestor);\r\n            if (ancestorMetadataMap) {\r\n                var metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(function (meta) { return meta.propertyName !== undefined; });\r\n                metadataFromAncestors.push.apply(metadataFromAncestors, metadataFromAncestor);\r\n            }\r\n        }\r\n        return metadataFromAncestors.concat(metadataFromTarget || []);\r\n    };\r\n    MetadataStorage.prototype.findMetadata = function (metadatas, target, propertyName) {\r\n        var metadataFromTargetMap = metadatas.get(target);\r\n        if (metadataFromTargetMap) {\r\n            var metadataFromTarget = metadataFromTargetMap.get(propertyName);\r\n            if (metadataFromTarget) {\r\n                return metadataFromTarget;\r\n            }\r\n        }\r\n        for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {\r\n            var ancestor = _a[_i];\r\n            var ancestorMetadataMap = metadatas.get(ancestor);\r\n            if (ancestorMetadataMap) {\r\n                var ancestorResult = ancestorMetadataMap.get(propertyName);\r\n                if (ancestorResult) {\r\n                    return ancestorResult;\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n    MetadataStorage.prototype.findMetadatas = function (metadatas, target, propertyName) {\r\n        var metadataFromTargetMap = metadatas.get(target);\r\n        var metadataFromTarget;\r\n        if (metadataFromTargetMap) {\r\n            metadataFromTarget = metadataFromTargetMap.get(propertyName);\r\n        }\r\n        var metadataFromAncestorsTarget = [];\r\n        for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {\r\n            var ancestor = _a[_i];\r\n            var ancestorMetadataMap = metadatas.get(ancestor);\r\n            if (ancestorMetadataMap) {\r\n                if (ancestorMetadataMap.has(propertyName)) {\r\n                    metadataFromAncestorsTarget.push.apply(metadataFromAncestorsTarget, ancestorMetadataMap.get(propertyName));\r\n                }\r\n            }\r\n        }\r\n        return metadataFromAncestorsTarget\r\n            .slice()\r\n            .reverse()\r\n            .concat((metadataFromTarget || []).slice().reverse());\r\n    };\r\n    MetadataStorage.prototype.getAncestors = function (target) {\r\n        if (!target)\r\n            return [];\r\n        if (!this._ancestorsMap.has(target)) {\r\n            var ancestors = [];\r\n            for (var baseClass = Object.getPrototypeOf(target.prototype.constructor); typeof baseClass.prototype !== 'undefined'; baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)) {\r\n                ancestors.push(baseClass);\r\n            }\r\n            this._ancestorsMap.set(target, ancestors);\r\n        }\r\n        return this._ancestorsMap.get(target);\r\n    };\r\n    return MetadataStorage;\r\n}());\r\nexport { MetadataStorage };\r\n//# sourceMappingURL=MetadataStorage.js.map","import { MetadataStorage } from './MetadataStorage';\r\n/**\r\n * Default metadata storage is used as singleton and can be used to storage all metadatas.\r\n */\r\nexport var defaultMetadataStorage = new MetadataStorage();\r\n//# sourceMappingURL=storage.js.map","import { defaultMetadataStorage } from './storage';\r\nimport { TransformationType } from './enums';\r\nimport { getGlobal } from './utils';\r\nfunction instantiateArrayType(arrayType) {\r\n    var array = new arrayType();\r\n    if (!(array instanceof Set) && !('push' in array)) {\r\n        return [];\r\n    }\r\n    return array;\r\n}\r\nvar TransformOperationExecutor = /** @class */ (function () {\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n    function TransformOperationExecutor(transformationType, options) {\r\n        this.transformationType = transformationType;\r\n        this.options = options;\r\n        // -------------------------------------------------------------------------\r\n        // Private Properties\r\n        // -------------------------------------------------------------------------\r\n        this.recursionStack = new Set();\r\n    }\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n    TransformOperationExecutor.prototype.transform = function (source, value, targetType, arrayType, isMap, level) {\r\n        var _this = this;\r\n        if (level === void 0) { level = 0; }\r\n        if (Array.isArray(value) || value instanceof Set) {\r\n            var newValue_1 = arrayType && this.transformationType === TransformationType.PLAIN_TO_CLASS\r\n                ? instantiateArrayType(arrayType)\r\n                : [];\r\n            value.forEach(function (subValue, index) {\r\n                var subSource = source ? source[index] : undefined;\r\n                if (!_this.options.enableCircularCheck || !_this.isCircular(subValue)) {\r\n                    var realTargetType = void 0;\r\n                    if (typeof targetType !== 'function' &&\r\n                        targetType &&\r\n                        targetType.options &&\r\n                        targetType.options.discriminator &&\r\n                        targetType.options.discriminator.property &&\r\n                        targetType.options.discriminator.subTypes) {\r\n                        if (_this.transformationType === TransformationType.PLAIN_TO_CLASS) {\r\n                            realTargetType = targetType.options.discriminator.subTypes.find(function (subType) {\r\n                                return subType.name === subValue[targetType.options.discriminator.property];\r\n                            });\r\n                            var options = { newObject: newValue_1, object: subValue, property: undefined };\r\n                            var newType = targetType.typeFunction(options);\r\n                            realTargetType === undefined ? (realTargetType = newType) : (realTargetType = realTargetType.value);\r\n                            if (!targetType.options.keepDiscriminatorProperty)\r\n                                delete subValue[targetType.options.discriminator.property];\r\n                        }\r\n                        if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {\r\n                            realTargetType = subValue.constructor;\r\n                        }\r\n                        if (_this.transformationType === TransformationType.CLASS_TO_PLAIN) {\r\n                            subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find(function (subType) { return subType.value === subValue.constructor; }).name;\r\n                        }\r\n                    }\r\n                    else {\r\n                        realTargetType = targetType;\r\n                    }\r\n                    var value_1 = _this.transform(subSource, subValue, realTargetType, undefined, subValue instanceof Map, level + 1);\r\n                    if (newValue_1 instanceof Set) {\r\n                        newValue_1.add(value_1);\r\n                    }\r\n                    else {\r\n                        newValue_1.push(value_1);\r\n                    }\r\n                }\r\n                else if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {\r\n                    if (newValue_1 instanceof Set) {\r\n                        newValue_1.add(subValue);\r\n                    }\r\n                    else {\r\n                        newValue_1.push(subValue);\r\n                    }\r\n                }\r\n            });\r\n            return newValue_1;\r\n        }\r\n        else if (targetType === String && !isMap) {\r\n            if (value === null || value === undefined)\r\n                return value;\r\n            return String(value);\r\n        }\r\n        else if (targetType === Number && !isMap) {\r\n            if (value === null || value === undefined)\r\n                return value;\r\n            return Number(value);\r\n        }\r\n        else if (targetType === Boolean && !isMap) {\r\n            if (value === null || value === undefined)\r\n                return value;\r\n            return Boolean(value);\r\n        }\r\n        else if ((targetType === Date || value instanceof Date) && !isMap) {\r\n            if (value instanceof Date) {\r\n                return new Date(value.valueOf());\r\n            }\r\n            if (value === null || value === undefined)\r\n                return value;\r\n            return new Date(value);\r\n        }\r\n        else if (!!getGlobal().Buffer && (targetType === Buffer || value instanceof Buffer) && !isMap) {\r\n            if (value === null || value === undefined)\r\n                return value;\r\n            return Buffer.from(value);\r\n        }\r\n        else if (typeof value === 'object' && value !== null) {\r\n            // try to guess the type\r\n            if (!targetType && value.constructor !== Object /* && TransformationType === TransformationType.CLASS_TO_PLAIN*/)\r\n                targetType = value.constructor;\r\n            if (!targetType && source)\r\n                targetType = source.constructor;\r\n            if (this.options.enableCircularCheck) {\r\n                // add transformed type to prevent circular references\r\n                this.recursionStack.add(value);\r\n            }\r\n            var keys = this.getKeys(targetType, value, isMap);\r\n            var newValue = source ? source : {};\r\n            if (!source &&\r\n                (this.transformationType === TransformationType.PLAIN_TO_CLASS ||\r\n                    this.transformationType === TransformationType.CLASS_TO_CLASS)) {\r\n                if (isMap) {\r\n                    newValue = new Map();\r\n                }\r\n                else if (targetType) {\r\n                    newValue = new targetType();\r\n                }\r\n                else {\r\n                    newValue = {};\r\n                }\r\n            }\r\n            var _loop_1 = function (key) {\r\n                if (key === '__proto__' || key === 'constructor') {\r\n                    return \"continue\";\r\n                }\r\n                var valueKey = key;\r\n                var newValueKey = key, propertyName = key;\r\n                if (!this_1.options.ignoreDecorators && targetType) {\r\n                    if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {\r\n                        var exposeMetadata = defaultMetadataStorage.findExposeMetadataByCustomName(targetType, key);\r\n                        if (exposeMetadata) {\r\n                            propertyName = exposeMetadata.propertyName;\r\n                            newValueKey = exposeMetadata.propertyName;\r\n                        }\r\n                    }\r\n                    else if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN ||\r\n                        this_1.transformationType === TransformationType.CLASS_TO_CLASS) {\r\n                        var exposeMetadata = defaultMetadataStorage.findExposeMetadata(targetType, key);\r\n                        if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\r\n                            newValueKey = exposeMetadata.options.name;\r\n                        }\r\n                    }\r\n                }\r\n                // get a subvalue\r\n                var subValue = undefined;\r\n                if (value instanceof Map) {\r\n                    subValue = value.get(valueKey);\r\n                }\r\n                else if (value[valueKey] instanceof Function) {\r\n                    subValue = value[valueKey]();\r\n                }\r\n                else {\r\n                    subValue = value[valueKey];\r\n                }\r\n                // determine a type\r\n                var type = undefined, isSubValueMap = subValue instanceof Map;\r\n                if (targetType && isMap) {\r\n                    type = targetType;\r\n                }\r\n                else if (targetType) {\r\n                    var metadata_1 = defaultMetadataStorage.findTypeMetadata(targetType, propertyName);\r\n                    if (metadata_1) {\r\n                        var options = { newObject: newValue, object: value, property: propertyName };\r\n                        var newType = metadata_1.typeFunction ? metadata_1.typeFunction(options) : metadata_1.reflectedType;\r\n                        if (metadata_1.options &&\r\n                            metadata_1.options.discriminator &&\r\n                            metadata_1.options.discriminator.property &&\r\n                            metadata_1.options.discriminator.subTypes) {\r\n                            if (!(value[valueKey] instanceof Array)) {\r\n                                if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {\r\n                                    type = metadata_1.options.discriminator.subTypes.find(function (subType) {\r\n                                        if (subValue && metadata_1.options.discriminator.property in subValue) {\r\n                                            return subType.name === subValue[metadata_1.options.discriminator.property];\r\n                                        }\r\n                                    });\r\n                                    type === undefined ? (type = newType) : (type = type.value);\r\n                                    if (!metadata_1.options.keepDiscriminatorProperty) {\r\n                                        if (subValue && metadata_1.options.discriminator.property in subValue) {\r\n                                            delete subValue[metadata_1.options.discriminator.property];\r\n                                        }\r\n                                    }\r\n                                }\r\n                                if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {\r\n                                    type = subValue.constructor;\r\n                                }\r\n                                if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {\r\n                                    subValue[metadata_1.options.discriminator.property] = metadata_1.options.discriminator.subTypes.find(function (subType) { return subType.value === subValue.constructor; }).name;\r\n                                }\r\n                            }\r\n                            else {\r\n                                type = metadata_1;\r\n                            }\r\n                        }\r\n                        else {\r\n                            type = newType;\r\n                        }\r\n                        isSubValueMap = isSubValueMap || metadata_1.reflectedType === Map;\r\n                    }\r\n                    else if (this_1.options.targetMaps) {\r\n                        // try to find a type in target maps\r\n                        this_1.options.targetMaps\r\n                            .filter(function (map) { return map.target === targetType && !!map.properties[propertyName]; })\r\n                            .forEach(function (map) { return (type = map.properties[propertyName]); });\r\n                    }\r\n                    else if (this_1.options.enableImplicitConversion &&\r\n                        this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {\r\n                        // if we have no registererd type via the @Type() decorator then we check if we have any\r\n                        // type declarations in reflect-metadata (type declaration is emited only if some decorator is added to the property.)\r\n                        var reflectedType = Reflect.getMetadata('design:type', targetType.prototype, propertyName);\r\n                        if (reflectedType) {\r\n                            type = reflectedType;\r\n                        }\r\n                    }\r\n                }\r\n                // if value is an array try to get its custom array type\r\n                var arrayType_1 = Array.isArray(value[valueKey])\r\n                    ? this_1.getReflectedType(targetType, propertyName)\r\n                    : undefined;\r\n                // const subValueKey = TransformationType === TransformationType.PLAIN_TO_CLASS && newKeyName ? newKeyName : key;\r\n                var subSource = source ? source[valueKey] : undefined;\r\n                // if its deserialization then type if required\r\n                // if we uncomment this types like string[] will not work\r\n                // if (this.transformationType === TransformationType.PLAIN_TO_CLASS && !type && subValue instanceof Object && !(subValue instanceof Date))\r\n                //     throw new Error(`Cannot determine type for ${(targetType as any).name }.${propertyName}, did you forget to specify a @Type?`);\r\n                // if newValue is a source object that has method that match newKeyName then skip it\r\n                if (newValue.constructor.prototype) {\r\n                    var descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);\r\n                    if ((this_1.transformationType === TransformationType.PLAIN_TO_CLASS ||\r\n                        this_1.transformationType === TransformationType.CLASS_TO_CLASS) &&\r\n                        // eslint-disable-next-line @typescript-eslint/unbound-method\r\n                        ((descriptor && !descriptor.set) || newValue[newValueKey] instanceof Function))\r\n                        return \"continue\";\r\n                }\r\n                if (!this_1.options.enableCircularCheck || !this_1.isCircular(subValue)) {\r\n                    var transformKey = this_1.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key;\r\n                    var finalValue = void 0;\r\n                    if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {\r\n                        // Get original value\r\n                        finalValue = value[transformKey];\r\n                        // Apply custom transformation\r\n                        finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value, this_1.transformationType);\r\n                        // If nothing change, it means no custom transformation was applied, so use the subValue.\r\n                        finalValue = value[transformKey] === finalValue ? subValue : finalValue;\r\n                        // Apply the default transformation\r\n                        finalValue = this_1.transform(subSource, finalValue, type, arrayType_1, isSubValueMap, level + 1);\r\n                    }\r\n                    else {\r\n                        if (subValue === undefined && this_1.options.exposeDefaultValues) {\r\n                            // Set default value if nothing provided\r\n                            finalValue = newValue[newValueKey];\r\n                        }\r\n                        else {\r\n                            finalValue = this_1.transform(subSource, subValue, type, arrayType_1, isSubValueMap, level + 1);\r\n                            finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value, this_1.transformationType);\r\n                        }\r\n                    }\r\n                    if (newValue instanceof Map) {\r\n                        newValue.set(newValueKey, finalValue);\r\n                    }\r\n                    else {\r\n                        newValue[newValueKey] = finalValue;\r\n                    }\r\n                }\r\n                else if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {\r\n                    var finalValue = subValue;\r\n                    finalValue = this_1.applyCustomTransformations(finalValue, targetType, key, value, this_1.transformationType);\r\n                    if (newValue instanceof Map) {\r\n                        newValue.set(newValueKey, finalValue);\r\n                    }\r\n                    else {\r\n                        newValue[newValueKey] = finalValue;\r\n                    }\r\n                }\r\n            };\r\n            var this_1 = this;\r\n            // traverse over keys\r\n            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\r\n                var key = keys_1[_i];\r\n                _loop_1(key);\r\n            }\r\n            if (this.options.enableCircularCheck) {\r\n                this.recursionStack.delete(value);\r\n            }\r\n            return newValue;\r\n        }\r\n        else {\r\n            return value;\r\n        }\r\n    };\r\n    TransformOperationExecutor.prototype.applyCustomTransformations = function (value, target, key, obj, transformationType) {\r\n        var _this = this;\r\n        var metadatas = defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType);\r\n        // apply versioning options\r\n        if (this.options.version !== undefined) {\r\n            metadatas = metadatas.filter(function (metadata) {\r\n                if (!metadata.options)\r\n                    return true;\r\n                return _this.checkVersion(metadata.options.since, metadata.options.until);\r\n            });\r\n        }\r\n        // apply grouping options\r\n        if (this.options.groups && this.options.groups.length) {\r\n            metadatas = metadatas.filter(function (metadata) {\r\n                if (!metadata.options)\r\n                    return true;\r\n                return _this.checkGroups(metadata.options.groups);\r\n            });\r\n        }\r\n        else {\r\n            metadatas = metadatas.filter(function (metadata) {\r\n                return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;\r\n            });\r\n        }\r\n        metadatas.forEach(function (metadata) {\r\n            value = metadata.transformFn({ value: value, key: key, obj: obj, type: transformationType });\r\n        });\r\n        return value;\r\n    };\r\n    // preventing circular references\r\n    TransformOperationExecutor.prototype.isCircular = function (object) {\r\n        return this.recursionStack.has(object);\r\n    };\r\n    TransformOperationExecutor.prototype.getReflectedType = function (target, propertyName) {\r\n        if (!target)\r\n            return undefined;\r\n        var meta = defaultMetadataStorage.findTypeMetadata(target, propertyName);\r\n        return meta ? meta.reflectedType : undefined;\r\n    };\r\n    TransformOperationExecutor.prototype.getKeys = function (target, object, isMap) {\r\n        var _this = this;\r\n        // determine exclusion strategy\r\n        var strategy = defaultMetadataStorage.getStrategy(target);\r\n        if (strategy === 'none')\r\n            strategy = this.options.strategy || 'exposeAll'; // exposeAll is default strategy\r\n        // get all keys that need to expose\r\n        var keys = [];\r\n        if (strategy === 'exposeAll' || isMap) {\r\n            if (object instanceof Map) {\r\n                keys = Array.from(object.keys());\r\n            }\r\n            else {\r\n                keys = Object.keys(object);\r\n            }\r\n        }\r\n        if (isMap) {\r\n            // expose & exclude do not apply for map keys only to fields\r\n            return keys;\r\n        }\r\n        if (!this.options.ignoreDecorators && target) {\r\n            // add all exposed to list of keys\r\n            var exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);\r\n            if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\r\n                exposedProperties = exposedProperties.map(function (key) {\r\n                    var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\r\n                    if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\r\n                        return exposeMetadata.options.name;\r\n                    }\r\n                    return key;\r\n                });\r\n            }\r\n            if (this.options.excludeExtraneousValues) {\r\n                keys = exposedProperties;\r\n            }\r\n            else {\r\n                keys = keys.concat(exposedProperties);\r\n            }\r\n            // exclude excluded properties\r\n            var excludedProperties_1 = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);\r\n            if (excludedProperties_1.length > 0) {\r\n                keys = keys.filter(function (key) {\r\n                    return !excludedProperties_1.includes(key);\r\n                });\r\n            }\r\n            // apply versioning options\r\n            if (this.options.version !== undefined) {\r\n                keys = keys.filter(function (key) {\r\n                    var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\r\n                    if (!exposeMetadata || !exposeMetadata.options)\r\n                        return true;\r\n                    return _this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);\r\n                });\r\n            }\r\n            // apply grouping options\r\n            if (this.options.groups && this.options.groups.length) {\r\n                keys = keys.filter(function (key) {\r\n                    var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\r\n                    if (!exposeMetadata || !exposeMetadata.options)\r\n                        return true;\r\n                    return _this.checkGroups(exposeMetadata.options.groups);\r\n                });\r\n            }\r\n            else {\r\n                keys = keys.filter(function (key) {\r\n                    var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\r\n                    return (!exposeMetadata ||\r\n                        !exposeMetadata.options ||\r\n                        !exposeMetadata.options.groups ||\r\n                        !exposeMetadata.options.groups.length);\r\n                });\r\n            }\r\n        }\r\n        // exclude prefixed properties\r\n        if (this.options.excludePrefixes && this.options.excludePrefixes.length) {\r\n            keys = keys.filter(function (key) {\r\n                return _this.options.excludePrefixes.every(function (prefix) {\r\n                    return key.substr(0, prefix.length) !== prefix;\r\n                });\r\n            });\r\n        }\r\n        // make sure we have unique keys\r\n        keys = keys.filter(function (key, index, self) {\r\n            return self.indexOf(key) === index;\r\n        });\r\n        return keys;\r\n    };\r\n    TransformOperationExecutor.prototype.checkVersion = function (since, until) {\r\n        var decision = true;\r\n        if (decision && since)\r\n            decision = this.options.version >= since;\r\n        if (decision && until)\r\n            decision = this.options.version < until;\r\n        return decision;\r\n    };\r\n    TransformOperationExecutor.prototype.checkGroups = function (groups) {\r\n        if (!groups)\r\n            return true;\r\n        return this.options.groups.some(function (optionGroup) { return groups.includes(optionGroup); });\r\n    };\r\n    return TransformOperationExecutor;\r\n}());\r\nexport { TransformOperationExecutor };\r\n//# sourceMappingURL=TransformOperationExecutor.js.map","/**\r\n * This function returns the global object across Node and browsers.\r\n *\r\n * Note: `globalThis` is the standardized approach however it has been added to\r\n * Node.js in version 12. We need to include this snippet until Node 12 EOL.\r\n */\r\nexport function getGlobal() {\r\n    if (typeof globalThis !== 'undefined') {\r\n        return globalThis;\r\n    }\r\n    if (typeof global !== 'undefined') {\r\n        return global;\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n    // @ts-ignore: Cannot find name 'window'.\r\n    if (typeof window !== 'undefined') {\r\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n        // @ts-ignore: Cannot find name 'window'.\r\n        return window;\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n    // @ts-ignore: Cannot find name 'self'.\r\n    if (typeof self !== 'undefined') {\r\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n        // @ts-ignore: Cannot find name 'self'.\r\n        return self;\r\n    }\r\n}\r\n//# sourceMappingURL=get-global.util.js.map","import { TransformOperationExecutor } from './TransformOperationExecutor';\r\nimport { TransformationType } from './enums';\r\nvar ClassTransformer = /** @class */ (function () {\r\n    function ClassTransformer() {\r\n    }\r\n    ClassTransformer.prototype.classToPlain = function (object, options) {\r\n        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, options || {});\r\n        return executor.transform(undefined, object, undefined, undefined, undefined, undefined);\r\n    };\r\n    ClassTransformer.prototype.classToPlainFromExist = function (object, plainObject, options) {\r\n        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, options || {});\r\n        return executor.transform(plainObject, object, undefined, undefined, undefined, undefined);\r\n    };\r\n    ClassTransformer.prototype.plainToClass = function (cls, plain, options) {\r\n        var executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, options || {});\r\n        return executor.transform(undefined, plain, cls, undefined, undefined, undefined);\r\n    };\r\n    ClassTransformer.prototype.plainToClassFromExist = function (clsObject, plain, options) {\r\n        var executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, options || {});\r\n        return executor.transform(clsObject, plain, undefined, undefined, undefined, undefined);\r\n    };\r\n    ClassTransformer.prototype.classToClass = function (object, options) {\r\n        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, options || {});\r\n        return executor.transform(undefined, object, undefined, undefined, undefined, undefined);\r\n    };\r\n    ClassTransformer.prototype.classToClassFromExist = function (object, fromObject, options) {\r\n        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, options || {});\r\n        return executor.transform(fromObject, object, undefined, undefined, undefined, undefined);\r\n    };\r\n    ClassTransformer.prototype.serialize = function (object, options) {\r\n        return JSON.stringify(this.classToPlain(object, options));\r\n    };\r\n    /**\r\n     * Deserializes given JSON string to a object of the given class.\r\n     */\r\n    ClassTransformer.prototype.deserialize = function (cls, json, options) {\r\n        var jsonObject = JSON.parse(json);\r\n        return this.plainToClass(cls, jsonObject, options);\r\n    };\r\n    /**\r\n     * Deserializes given JSON string to an array of objects of the given class.\r\n     */\r\n    ClassTransformer.prototype.deserializeArray = function (cls, json, options) {\r\n        var jsonObject = JSON.parse(json);\r\n        return this.plainToClass(cls, jsonObject, options);\r\n    };\r\n    return ClassTransformer;\r\n}());\r\nexport { ClassTransformer };\r\n//# sourceMappingURL=ClassTransformer.js.map","import { ClassTransformer } from './ClassTransformer';\r\nexport { ClassTransformer } from './ClassTransformer';\r\nexport * from './decorators';\r\nexport * from './interfaces';\r\nexport * from './enums';\r\nvar classTransformer = new ClassTransformer();\r\nexport function classToPlain(object, options) {\r\n    return classTransformer.classToPlain(object, options);\r\n}\r\nexport function classToPlainFromExist(object, plainObject, options) {\r\n    return classTransformer.classToPlainFromExist(object, plainObject, options);\r\n}\r\nexport function plainToClass(cls, plain, options) {\r\n    return classTransformer.plainToClass(cls, plain, options);\r\n}\r\nexport function plainToClassFromExist(clsObject, plain, options) {\r\n    return classTransformer.plainToClassFromExist(clsObject, plain, options);\r\n}\r\nexport function classToClass(object, options) {\r\n    return classTransformer.classToClass(object, options);\r\n}\r\nexport function classToClassFromExist(object, fromObject, options) {\r\n    return classTransformer.classToClassFromExist(object, fromObject, options);\r\n}\r\nexport function serialize(object, options) {\r\n    return classTransformer.serialize(object, options);\r\n}\r\n/**\r\n * Deserializes given JSON string to a object of the given class.\r\n */\r\nexport function deserialize(cls, json, options) {\r\n    return classTransformer.deserialize(cls, json, options);\r\n}\r\n/**\r\n * Deserializes given JSON string to an array of objects of the given class.\r\n */\r\nexport function deserializeArray(cls, json, options) {\r\n    return classTransformer.deserializeArray(cls, json, options);\r\n}\r\n//# sourceMappingURL=index.js.map","import { defaultMetadataStorage } from '../storage';\r\n/**\r\n * Marks the given class or property as excluded. By default the property is excluded in both\r\n * constructorToPlain and plainToConstructor transformations. It can be limited to only one direction\r\n * via using the `toPlainOnly` or `toClassOnly` option.\r\n *\r\n * Can be applied to class definitions and properties.\r\n */\r\nexport function Exclude(options) {\r\n    if (options === void 0) { options = {}; }\r\n    /**\r\n     * NOTE: The `propertyName` property must be marked as optional because\r\n     * this decorator used both as a class and a property decorator and the\r\n     * Typescript compiler will freak out if we make it mandatory as a class\r\n     * decorator only receives one parameter.\r\n     */\r\n    return function (object, propertyName) {\r\n        defaultMetadataStorage.addExcludeMetadata({\r\n            target: object instanceof Function ? object : object.constructor,\r\n            propertyName: propertyName,\r\n            options: options,\r\n        });\r\n    };\r\n}\r\n//# sourceMappingURL=exclude.decorator.js.map","import { defaultMetadataStorage } from '../storage';\r\n/**\r\n * Marks the given class or property as included. By default the property is included in both\r\n * constructorToPlain and plainToConstructor transformations. It can be limited to only one direction\r\n * via using the `toPlainOnly` or `toClassOnly` option.\r\n *\r\n * Can be applied to class definitions and properties.\r\n */\r\nexport function Expose(options) {\r\n    if (options === void 0) { options = {}; }\r\n    /**\r\n     * NOTE: The `propertyName` property must be marked as optional because\r\n     * this decorator used both as a class and a property decorator and the\r\n     * Typescript compiler will freak out if we make it mandatory as a class\r\n     * decorator only receives one parameter.\r\n     */\r\n    return function (object, propertyName) {\r\n        defaultMetadataStorage.addExposeMetadata({\r\n            target: object instanceof Function ? object : object.constructor,\r\n            propertyName: propertyName,\r\n            options: options,\r\n        });\r\n    };\r\n}\r\n//# sourceMappingURL=expose.decorator.js.map","import { defaultMetadataStorage } from '../storage';\r\n/**\r\n * Defines a custom logic for value transformation.\r\n *\r\n * Can be applied to properties only.\r\n */\r\nexport function Transform(transformFn, options) {\r\n    if (options === void 0) { options = {}; }\r\n    return function (target, propertyName) {\r\n        defaultMetadataStorage.addTransformMetadata({\r\n            target: target.constructor,\r\n            propertyName: propertyName,\r\n            transformFn: transformFn,\r\n            options: options,\r\n        });\r\n    };\r\n}\r\n//# sourceMappingURL=transform.decorator.js.map","import { ClassTransformer } from '../ClassTransformer';\r\n/**\r\n * Return the class instance only with the exposed properties.\r\n *\r\n * Can be applied to functions and getters/setters only.\r\n */\r\nexport function TransformClassToClass(params) {\r\n    return function (target, propertyKey, descriptor) {\r\n        var classTransformer = new ClassTransformer();\r\n        var originalMethod = descriptor.value;\r\n        descriptor.value = function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            var result = originalMethod.apply(this, args);\r\n            var isPromise = !!result && (typeof result === 'object' || typeof result === 'function') && typeof result.then === 'function';\r\n            return isPromise\r\n                ? result.then(function (data) { return classTransformer.classToClass(data, params); })\r\n                : classTransformer.classToClass(result, params);\r\n        };\r\n    };\r\n}\r\n//# sourceMappingURL=transform-class-to-class.decorator.js.map","import { ClassTransformer } from '../ClassTransformer';\r\n/**\r\n * Transform the object from class to plain object and return only with the exposed properties.\r\n *\r\n * Can be applied to functions and getters/setters only.\r\n */\r\nexport function TransformClassToPlain(params) {\r\n    return function (target, propertyKey, descriptor) {\r\n        var classTransformer = new ClassTransformer();\r\n        var originalMethod = descriptor.value;\r\n        descriptor.value = function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            var result = originalMethod.apply(this, args);\r\n            var isPromise = !!result && (typeof result === 'object' || typeof result === 'function') && typeof result.then === 'function';\r\n            return isPromise\r\n                ? result.then(function (data) { return classTransformer.classToPlain(data, params); })\r\n                : classTransformer.classToPlain(result, params);\r\n        };\r\n    };\r\n}\r\n//# sourceMappingURL=transform-class-to-plain.decorator.js.map","import { ClassTransformer } from '../ClassTransformer';\r\n/**\r\n * Return the class instance only with the exposed properties.\r\n *\r\n * Can be applied to functions and getters/setters only.\r\n */\r\nexport function TransformPlainToClass(classType, params) {\r\n    return function (target, propertyKey, descriptor) {\r\n        var classTransformer = new ClassTransformer();\r\n        var originalMethod = descriptor.value;\r\n        descriptor.value = function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            var result = originalMethod.apply(this, args);\r\n            var isPromise = !!result && (typeof result === 'object' || typeof result === 'function') && typeof result.then === 'function';\r\n            return isPromise\r\n                ? result.then(function (data) { return classTransformer.plainToClass(classType, data, params); })\r\n                : classTransformer.plainToClass(classType, result, params);\r\n        };\r\n    };\r\n}\r\n//# sourceMappingURL=transform-plain-to-class.decorator.js.map","import { defaultMetadataStorage } from '../storage';\r\n/**\r\n * Specifies a type of the property.\r\n * The given TypeFunction can return a constructor. A discriminator can be given in the options.\r\n *\r\n * Can be applied to properties only.\r\n */\r\nexport function Type(typeFunction, options) {\r\n    if (options === void 0) { options = {}; }\r\n    return function (target, propertyName) {\r\n        var reflectedType = Reflect.getMetadata('design:type', target, propertyName);\r\n        defaultMetadataStorage.addTypeMetadata({\r\n            target: target.constructor,\r\n            propertyName: propertyName,\r\n            reflectedType: reflectedType,\r\n            typeFunction: typeFunction,\r\n            options: options,\r\n        });\r\n    };\r\n}\r\n//# sourceMappingURL=type.decorator.js.map"],"names":["TransformationType","defaultMetadataStorage","MetadataStorage","this","_typeMetadatas","Map","_transformMetadatas","_exposeMetadatas","_excludeMetadatas","_ancestorsMap","prototype","addTypeMetadata","metadata","has","target","set","get","propertyName","addTransformMetadata","push","addExposeMetadata","addExcludeMetadata","findTransformMetadatas","transformationType","findMetadatas","filter","options","toClassOnly","toPlainOnly","CLASS_TO_CLASS","PLAIN_TO_CLASS","CLASS_TO_PLAIN","findExcludeMetadata","findMetadata","findExposeMetadata","findExposeMetadataByCustomName","name","getExposedMetadatas","find","findTypeMetadata","getStrategy","excludeMap","exclude","undefined","exposeMap","expose","getMetadata","getExcludedMetadatas","getExposedProperties","map","getExcludedProperties","clear","metadatas","metadataFromTarget","metadataFromTargetMap","Array","from","values","meta","metadataFromAncestors","_i","_a","getAncestors","length","ancestor","ancestorMetadataMap","metadataFromAncestor","apply","concat","ancestorResult","metadataFromAncestorsTarget","slice","reverse","ancestors","baseClass","Object","getPrototypeOf","constructor","TransformOperationExecutor","recursionStack","Set","transform","source","value","targetType","arrayType","isMap","level","_this","isArray","newValue_1","array","instantiateArrayType","forEach","subValue","index","subSource","enableCircularCheck","isCircular","add","realTargetType","discriminator","property","subTypes","subType","newObject","object","newType","typeFunction","keepDiscriminatorProperty","value_1","String","Number","Boolean","Date","valueOf","globalThis","global","window","self","Buffer","keys","getKeys","newValue","_loop_1","key","valueKey","newValueKey","this_1","ignoreDecorators","exposeMetadata","Function","type","isSubValueMap","metadata_1","reflectedType","targetMaps","properties","enableImplicitConversion","Reflect","arrayType_1","getReflectedType","descriptor","getOwnPropertyDescriptor","finalValue","applyCustomTransformations","transformKey","exposeDefaultValues","keys_1","delete","obj","version","checkVersion","since","until","groups","checkGroups","transformFn","strategy","exposedProperties","excludeExtraneousValues","excludedProperties_1","includes","excludePrefixes","every","prefix","substr","indexOf","decision","some","optionGroup","ClassTransformer","classToPlain","classToPlainFromExist","plainObject","plainToClass","cls","plain","plainToClassFromExist","clsObject","classToClass","classToClassFromExist","fromObject","serialize","JSON","stringify","deserialize","json","jsonObject","parse","deserializeArray","classTransformer","params","propertyKey","originalMethod","args","arguments","result","isPromise","then","data","classType"],"mappings":"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"}